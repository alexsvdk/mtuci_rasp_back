/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package ru.mtuci.parser

import org.apache.poi.ss.usermodel.Row
import org.apache.poi.ss.usermodel.Sheet
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.jsoup.Jsoup
import ru.mtuci.core.GroupsRepository
import ru.mtuci.di.koin
import ru.mtuci.models.Group
import save
import java.net.URL

fun main() {
    koin
    val urls = getRaspUrls()
    urls.forEach(::processTable)
}

fun getRaspUrls(): List<String> {
    val page = Jsoup.connect("https://mtuci.ru/time-table/").get()
    val table = page.select("body > div.content > div > div:nth-child(2) > div > ul > li")
    return table
        .map {
            it.selectFirst("a")?.attr("href")
        }
        .filterNotNull()
        .filter { it.endsWith(".xlsx") }
        .toList()
}

fun processTable(url: String) {
    var url = url
    if (!url.contains("http")) {
        url = "https://mtuci.ru$url"
    }
    val table = XSSFWorkbook(URL(url).openStream())
    for (n in 0 until table.numberOfSheets) {
        processSheet(table.getSheetAt(n))
    }
}

fun processSheet(sheet: Sheet) {

    val str = sheet.getRow(5).getCell(0).stringCellValue;
    if (!str.contains("Расписание", ignoreCase = true)) {
        print("Skipping: $str")
        return;
    }

    val group = getGroupByName(sheet.sheetName)


    val rawLessons = mutableListOf<RawRepeatedLesson>()

    for (day in 0..5) for (lessonNum in 0..4) {
        rawLessons.addAll(
            parseRawLessons(sheet.getRow(13 + 6 * day + lessonNum), day),
        )
    }

    val lessons = rawLessons.map { it.buildLesson() }

    lessons.forEach {
        group.id?.let { it1 -> it.groupIds.add(it1) }
        it.save()
    }

}

fun parseRawLessons(row: Row, day: Int): List<RawRepeatedLesson> {

    //left
    val raw1 = try {
        RawRepeatedLesson(day).apply {
            name = row.getCell(6).stringCellValue.trim()
            teacher = row.getCell(5).stringCellValue.trim()
            type = row.getCell(4).stringCellValue.trim()
            dist = row.getCell(3).stringCellValue.trim() == "дист"
            num = row.getCell(1).numericCellValue.toInt()
        }
    } catch (e: Exception) {
        null
    }

    //right
    val raw2 = try {
        RawRepeatedLesson(day + 7).apply {
            name = row.getCell(7).stringCellValue.trim()
            teacher = row.getCell(8).stringCellValue.trim()
            type = row.getCell(9).stringCellValue.trim()
            dist = row.getCell(10)
                .stringCellValue.trim() == "дист"
            num = row.getCell(11).numericCellValue.toInt()
            sec = true
        }
    } catch (e: Exception) {
        null
    }

    return mutableListOf<RawRepeatedLesson>().apply {
        if (raw1?.name?.isNotEmpty() == true) add(raw1)
        if (raw2?.name?.isNotEmpty() == true) add(raw2)
    }
}

fun getGroupByName(name: String): Group {
    val repo = koin.get<GroupsRepository>()
    return repo.findByName(name) ?: Group().let {
        it.name = name
        repo.save(it)
    }
}
